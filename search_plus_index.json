{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-09 00:06:33 "},"chapter1/":{"url":"chapter1/","title":"安装","keywords":"","body":"安装 本项目基于cmake构建，cmake的结构来自于libigl/libigl-example-project, 这是一个空白的项目示例，展示了如何使用libigl和cmake。 libigl tutorial 本项目的显示模块基于libigl，因此需要先了解libigl的基本内容和如何安装运行。libigl tutorial. libigl下载 libigl的Github项目地址为libigl 可以使用git clone下载libigl源代码 git clone https://github.com/libigl/libigl 也可以在网页上点击Clone or download下载zip源代码压缩包。 build libigl 使用标准cmake流程构建libigl cd libigl/ mkdir build cd build cmake ../ make 在Windows中，可以使用cmake-gui，指定平台为Visual Studio 2015，从而生成VS2015的解决方案，用VS2015打开即可编译运行。 Compile 在下载和安装libigl之后, 你需要将libigl的路径添加到本项目的cmake/FindLIBIGL.cmake文件中。 find_path(LIBIGL_INCLUDE_DIR igl/readOBJ.h HINTS ENV LIBIGL ENV LIBIGLROOT ENV LIBIGL_ROOT ENV LIBIGL_DIR PATHS {% math2 %}{CMAKE_SOURCE_DIR}/../.. {% endmath2 %}{CMAKE_SOURCE_DIR}/.. {% math2 %}{CMAKE_SOURCE_DIR} {% endmath2 %}{CMAKE_SOURCE_DIR}/libigl {% math2 %}{CMAKE_SOURCE_DIR}/../libigl {% endmath2 %}{CMAKE_SOURCE_DIR}/../../libigl D:/Program\\ Files/libigl # 你可以在这里添加libigl的路径 /usr /usr/local /usr/local/igl/libigl PATH_SUFFIXES include ) 使用标准cmake流程编译此项目 mkdir build cd build cmake .. 在Windows中，可以使用cmake-gui，指定平台为Visual Studio 2015，从而生成VS2015的解决方案。 这时在build目录下会生成Tspline.sln。 用VS2015打开，即可编译运行程序。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 23:45:26 "},"chapter2/":{"url":"chapter2/","title":"NURBS","keywords":"","body":"NURBS NURBS模块主要包含NURBS曲线曲面的定义、求值、基函数求导、节点插入、插值、lspia拟合、显示等功能。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-05 17:00:14 "},"chapter2/NURBS曲线.html":{"url":"chapter2/NURBS曲线.html","title":"NURBS曲线","keywords":"","body":"NURBS曲线 相关文件： NURBSCurve.h NURBSCurve.cpp 设NURBS曲线 P(t) 的阶为k，控制顶点为P_0,P_1,\\ldots,P_n，对应的权重为w_0, w_1, \\ldots, w_n，节点向量为t_0,t_1,\\ldots,t_{n+k}，则曲线方程为： P(t) = \\frac{\\sum_{i=0}^{n}w_iP_iN_{i,k}(t)}{\\sum_{i=0}^{n}w_iN_{i,k}(t)} 将w_i, P_i表示为齐次坐标形式，即\\widetilde{P}_i = \\{w_iP_i, w_i\\}，则 \\widetilde{P}(t) = \\sum_{i=0}^{n}\\widetilde{P}_iN_{i,k}(t) 在NURBSCurve类中controlPw即表示了齐次形式的控制顶点。 NURBSCurve类 下面是NURBSCurve的类表示 #ifndef NURBSCURVE_H #define NURBSCURVE_H #include using namespace Eigen; using namespace std; struct NURBSCurve { NURBSCurve(){} /*input format: _n : P_0,P_1,...,P_n; _n is the final index _k : order of BSpline _controlP: P_0,P_1,...,P_n; (n+1) by 2 or 3 _knots : t_0,t_1,...,t_(n+k); */ NURBSCurve(int _n, int _k, MatrixXd _controlP, VectorXd _knots, bool _isRational = false); bool isRational = false; int n; // P_0,P_1,...,P_n; _n is the final index int k; // order of BSpline VectorXd knots; MatrixXd controlP; MatrixXd controlPw; }; #endif // !NURBSCURVE_H NURBSCurve文件格式 以下两个函数用于读取和保存NURBSCurve // load bool loadNURBS(string); // save bool saveNURBS(string); 其中NRUBSCurve的格式的一个例子如下： # NURBSCurve 非有理格式示例 0 # isRational，0表示非有理 6 4 # n k 3 # 控制点坐标维数 2 3 0 # 控制点坐标 1.5 1 0 - 1 1 0 - 2 0 0 - 1 - 1 0 1 - 1 0 2 0 0 0 0 0 0 0.25 0.5 0.75 1 1 1 1 # 节点向量 ---------------------------------------------------------- 1 # isRational, 1表示有理 6 3 # n k 4 # 齐次坐标形式的维数 1 0 0 1 # 齐次坐标 0.5 0.5 0 0.5 -0.5 0.5 0 0.5 -1 0 0 1 -0.5 -0.5 0 0.5 0.5 -0.5 0 0.5 1 0 0 1 0 0 0 0.25 0.5 0.5 0.75 1 1 1 # 节点向量 NURBSCurve显示 // display by libigl void draw(igl::opengl::glfw::Viewer& viewer, bool showpolygon=true,bool showsurface=true,double resolution = 0.01, Eigen::RowVector3d color = Eigen::RowVector3d(1, 0, 0)); // draw controlpolygon void drawControlPolygon(igl::opengl::glfw::Viewer &viewer); // draw NURBS surface void drawSurface(igl::opengl::glfw::Viewer &viewer, double resolution = 0.01, Eigen::RowVector3d color = Eigen::RowVector3d(1, 0, 0)); 如上代码所示，调用draw函数可以通过showpolygon,showsurface两个布尔变量控制显示控制网格和NURBS曲线。 API NURBSCurve的主要函数如下，具体实现细节见代码 // This file is part of NURBS, a simple NURBS library. // github repo: https://github.com/aijm/NURBS // Copyright (C) 2018 Jiaming Ai #ifndef NURBSCURVE_H #define NURBSCURVE_H #include using namespace Eigen; using namespace std; struct NURBSCurve { NURBSCurve(){} /*input format: _n : P_0,P_1,...,P_n; _n is the final index _k : order of BSpline _controlP: P_0,P_1,...,P_n; (n+1) by 2 or 3 _knots : t_0,t_1,...,t_(n+k); */ NURBSCurve(int _n, int _k, MatrixXd _controlP, VectorXd _knots, bool _isRational = false); NURBSCurve(const NURBSCurve &curve){ isRational = curve.isRational; n = curve.n; k = curve.k; knots = curve.knots; controlPw = curve.controlPw; } NURBSCurve& operator=(const NURBSCurve &curve){ isRational = curve.isRational; n = curve.n; k = curve.k; knots = curve.knots; controlPw = curve.controlPw; return *this; } // load bool loadNURBS(string); // save bool saveNURBS(string); // find the knot interval of t by binary searching int find_ind(double t)const; // evaluate the coordinate of curvePoint with parameter t MatrixXd eval(double t)const; MatrixXd eval_tangent(double t) const; // chord length parameterization static VectorXd parameterize(const MatrixXd &points); // basis function N_(i,p)(t) static double Basis(const VectorXd &_knots, double _t, int _i = 0, int _p = 3); // Berivative of Blending function N[s0,s1,s2,s3,s4](t) static Eigen::RowVectorXd DersBasis(const Eigen::MatrixXd &knots, double t, int i = 0, int p = 3); // interpolate by bspline of degree 3 void interpolate(const MatrixXd &points); // interpolate with appointed knot vector void interpolate(const MatrixXd &points, const VectorXd &knotvector); // interpolate with tangent constraint void interpolate_tangent(const MatrixXd &points, const MatrixXd &tangent); // interpolate with tangent constraint void interpolate_tangent(const MatrixXd &points, const MatrixXd &tangent, const VectorXd &params); // interpolate with tangent constraint void interpolate_tangent_improve(const MatrixXd &points, const MatrixXd &tangent, const VectorXd &params); // interpolate with tangent constraint void interpolate_optimize(const MatrixXd &points, const MatrixXd &tangent, double learning_rate = 0.01); // interpolate with tangent constraint void interpolate_optimize(const MatrixXd &points, const MatrixXd &tangent, const VectorXd &params, double learning_rate = 0.01); // interpolate with tangent constraint void interpolate_optimize1(const MatrixXd &points, const MatrixXd &tangent, const VectorXd &params, double learning_rate = 0.01); // pia fit by B-spline of degree 3 void piafit(const MatrixXd &points,int max_iter_num=100, double eps=1e-5); // pia fit with appointed knot vector void piafit(const MatrixXd &points, const VectorXd &knotvector, int max_iter_num = 100, double eps = 1e-5); // given Q_0,...,Q_m, fit by B-spline with control points P_0,...,P_n void lspiafit(const MatrixXd & points, int n_cpts, int max_iter_num = 100, double eps = 1e-5); // lspia fit with appointed knot vector void lspiafit(const MatrixXd & points, const VectorXd& params, int n_cpts, const VectorXd & knotvector, int max_iter_num = 100, double eps = 1e-5); // lspia fit with appointed knot vector void lspiafit(const MatrixXd & points, const VectorXd& params, const MatrixXd& cpts, const VectorXd & knotvector, int max_iter_num = 100, double eps = 1e-5); // kont insertion bool insert(double t); // display by libigl void draw(igl::opengl::glfw::Viewer& viewer, bool showpolygon=true,bool showsurface=true,double resolution = 0.01, Eigen::RowVector3d color = Eigen::RowVector3d(1, 0, 0)); // draw controlpolygon void drawControlPolygon(igl::opengl::glfw::Viewer &viewer); // draw NURBS surface void drawSurface(igl::opengl::glfw::Viewer &viewer, double resolution = 0.01, Eigen::RowVector3d color = Eigen::RowVector3d(1, 0, 0)); bool isRational = false; int n; // P_0,P_1,...,P_n; _n is the final index int k; // order of BSpline VectorXd knots; MatrixXd controlP; MatrixXd controlPw; }; #endif // !NURBSCURVE_H Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-07 19:51:38 "},"chapter2/NURBS曲面.html":{"url":"chapter2/NURBS曲面.html","title":"NURBS曲面","keywords":"","body":"NURBS曲面 相关文件： NURBSSurface.h NURBSSurface.cpp 设NURBS曲面 S(u,v) 的u,v方向的阶为k_u,k_v，控制顶点为\\{P_{ij}\\},i=0,1,\\ldots,m;j=0,1,,\\ldots,n，u方向节点向量为u_0,u_1,\\ldots,u_{m+k_u}，v方向节点向量为v_0,v_1,\\ldots,v_{n+k_v}，则曲线方程为： S(u,v) = \\sum_{i=0}^m\\sum_{j=0}^nP_{ij}N_{i,k_u}(u)N_{j,k_v}(v) NURBSSurface类 下面是NURBSSurface的类表示: // This file is part of NURBS, a simple NURBS library. // github repo: https://github.com/aijm/NURBS // Copyright (C) 2018 Jiaming Ai using namespace Eigen; using namespace std; struct NURBSSurface { NURBSSurface():id(-1),isRational(false){} /*input format: _order : // _order(0):u direction; _order(1): v direction _controlP: _controlP[i] represents u direction control point ,matrix (m+1) by 3 or 4 v | _controlP[n]: | P_0n P_1n ... P_mn _controlP[i]: | ... _controlP[1]: | P_01 P_11 ... P_m1 _controlP[0]: | P_00 P_10 ... P_m0 ------------------------> u _uknots : u_0,u_1,...,u_(m+u_order) _vknots : v_0,v_1,...,v_(n+v_order) _isRational: */ bool isRational = false; int u_order; // order of u direction int v_order; // order of v direction int u_num; // the final index of u direction control point int v_num; // the final index of v direction control point VectorXd uknots; // knots vector u direction : u_0, u_1, ..., u_(m + u_order) VectorXd vknots; // knots vector v direction : v_0,v_1,...,v_(n+v_order) vector controlP; vector controlPw; int dimension; // the dimension of control point 2 or 3 or 4 // use libigl mesh(V,F) structure to show the surface MatrixXd mesh_V; MatrixXi mesh_F; int id; }; 其中控制顶点通过vector表示，vector中每一项存储了一行u方向的控制顶点。 NURBSSurface文件格式 以下几个函数用于读取和保存NURBSSurface，以及将曲面离散保存为三角网格 // load bool loadNURBS(string); // save bool saveNURBS(string); // 按resolution间隔划分参数域，将曲面离散为三角网格并保存为OBJ格式 bool saveAsObj(string, double resolution = 0.01); NURBSSurface详细的文件格式见loadNURBS,saveNURBS的具体实现， 以下是一个简单的例子(#为注释，实际文件中需去除)： # 控制顶点为P[i][j] 0 # isRational, 0表示非有理，1表示有理 5 5 # u_num, v_num 4 4 # u_order, v_order 3 # 点的维数 -25 -25 -10 ,-25 -15 -5 ,-25 -5 0 ,-25 5 0 ,-25 15 -5 ,-25 25 -10, # P[0] -15 -25 -8 ,-15 -15 -4 ,-15 -5 -4 ,-15 5 -4 ,-15 15 -4 ,-15 25 -8, # P[1] -5 -25 -5 ,-5 -15 -3 ,-5 -5 -8 ,-5 5 -8 ,-5 15 -3 ,-5 25 -5, # P[2] 5 -25 -3 ,5 -15 -2 ,5 -5 -8 ,5 5 -8 ,5 15 -2 ,5 25 -3, # P[3] 15 -25 -8 ,15 -15 -4 ,15 -5 -4 ,15 5 -4 ,15 15 -4 ,15 25 -8, # P[4] 25 -25 -10 ,25 -15 -5 ,25 -5 2 ,25 5 2 ,25 15 -5 ,25 25 -10, # P[5] 0 0 0 0 1 2 3 3 3 3 # u_knots 0 0 0 0 1 2 3 3 3 3 # v_knots 另一种文件格式 另一种文件格式的例子见out/nurbs/Bsurface.cpt，该文件格式的读取、保存见test.h文件中两个函数 // test.h static void load_nurbs_surface(NURBSSurface& surface, string filename); static void save_nurbs_surface(const NURBSSurface& surface, string filename); 实际测试读取、保存见： // test.h static void test_load_nurbs_surface(); static void test_save_nurbs_surface(); NURBS曲面显示 显示相关函数如下： // display by libigl void draw(igl::opengl::glfw::Viewer& viewer, bool showpolygon=true,bool showsurface=true,double resolution = 0.01); // draw controlpolygon void drawControlPolygon(igl::opengl::glfw::Viewer &viewer); // draw NURBS surface void drawSurface(igl::opengl::glfw::Viewer &viewer, double resolution = 0.01); 调用draw函数可以通过showpolygon,showsurface两个布尔变量控制显示控制网格和NURBS曲面。 而NURBS曲面是通过resolution划分参数域进而离散为三角网格，在libigl中表示为MatrixXd mesh_V,MatrixXi mesh_F，则libigl可以渲染显示。 显示平均曲率，高斯曲率 在drawSurface函数中，以下代码用于计算平均曲率并为曲面加上相应的颜色映射用于显示 Eigen::MatrixXd HN; Eigen::VectorXd H; Eigen::SparseMatrix L, M, Minv; igl::cotmatrix(mesh_V, mesh_F, L); igl::massmatrix(mesh_V, mesh_F, igl::MASSMATRIX_TYPE_VORONOI, M); igl::invert_diag(M, Minv); HN = -Minv*(L*mesh_V); H = HN.rowwise().norm(); //up to sign // compute curvatrue directions via quadric fitting Eigen::MatrixXd PD1, PD2; Eigen::VectorXd PV1, PV2; igl::principal_curvature(mesh_V, mesh_F, PD1, PD2, PV1, PV2); // mean curvature H = 0.5*(PV1 + PV2); // Compute pseudocolor Eigen::MatrixXd C; igl::jet(H, true, C); viewer.data().set_colors(C); 高斯曲率也可以通过igl的相关模块实现，具体请见libigl相关内容。 高斯曲率 平均曲率 API NURBSSurface的函数如下，具体实现细节见代码 // This file is part of NURBS, a simple NURBS library. // github repo: https://github.com/aijm/NURBS // Copyright (C) 2018 Jiaming Ai #ifndef NURBSSURFACE_H #define NURBSSURFACE_H using namespace Eigen; using namespace std; struct NURBSSurface { NURBSSurface():id(-1),isRational(false){} NURBSSurface(VectorXi _order, vector _controlP, VectorXd _uknots, VectorXd _vknots, bool _isRational = false); // load bool loadNURBS(string); // save bool saveNURBS(string); // 按resolution间隔划分参数域，将曲面离散为三角网格并保存为OBJ格式 bool saveAsObj(string, double resolution = 0.01); // find the knot interval of t by binary searching int find_ind(double t, int k, int n, const VectorXd& knots); // calculate coordinate of curve point with parameter u & v MatrixXd eval(double u, double v) const; MatrixXd eval(double t, const MatrixXd &_controlP, const VectorXd &knots); // 获取等参线 void get_isoparam_curve(NURBSCurve& curve, double t, char dir = 'u'); // knot insertion bool insert(double s, char dir='u'); // kont insertion bool insert(double s, double t); // display by libigl void draw(igl::opengl::glfw::Viewer& viewer, bool showpolygon=true,bool showsurface=true,double resolution = 0.01); // draw controlpolygon void drawControlPolygon(igl::opengl::glfw::Viewer &viewer); // draw NURBS surface void drawSurface(igl::opengl::glfw::Viewer &viewer, double resolution = 0.01); // surface skinning void skinning(const vector &curves, igl::opengl::glfw::Viewer &viewer); // surface skinning void skinning(const vector &curves,const VectorXd& curves_param, igl::opengl::glfw::Viewer &viewer); public: double mean_curvature(double u, double v) const; double guassian_curvature(double u, double v) const; void curvature(double u, double v, double& k1, double& k2) const; void derivative(double u, double v, RowVector3d& du, RowVector3d& dv, RowVector3d& d2u, RowVector3d& d2v, RowVector3d& duv) const; static int FindSpan(const Eigen::MatrixXd &knots, double t, int p = 3); }; #endif // !NURBSSURFACE_H Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-07 20:43:34 "},"chapter2/Window.html":{"url":"chapter2/Window.html","title":"Window显示窗口模块","keywords":"","body":"Window显示窗口模块 相关文件： Window.h Window.cpp libigl中可以为显示窗口添加菜单栏，具体实现见View Menu，具体显示效果如下图： 为了使用这个功能，如果仅仅在main.cpp中添加，会使得代码非常混乱，为了解决这个问题，本软件进行了封装模块化，具体见Window类的实现。 有了Window模块，代码可非常简洁明了。 以Test.cpp中的绘制简单B样条曲线为例，可以很简单的通过Window模块显示。 void Test::test_nurbs() { // bezier curve NURBSCurve nurbs; nurbs.loadNURBS(\"../out/nurbs/bezier1.cpt\"); nurbs.draw(Window::viewer); // 使用Window模块 Window w; w.launch(); } Window模块的具体实现见代码。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-07 20:58:06 "},"chapter3/":{"url":"chapter3/","title":"Tspline","keywords":"","body":"Tspline 相关文件： array.hpp node.hpp mesh.hpp utility.h utility.cpp MeshRender.h MeshRender.cpp Tspline模块主要包含表示T样条的数据结构，T样条显示等功能。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 10:43:34 "},"chapter3/Tspline数据结构及常用API.html":{"url":"chapter3/Tspline数据结构及常用API.html","title":"Tspline数据结构及常用API","keywords":"","body":"Tspline数据结构及常用API 相关文件： array.hpp: node.hpp: mesh.hpp: utility.h utility.cpp 其中Array,Node为T样条的辅助数据结构。 设T样条曲面一个节点处的节点向量为\\boldsymbol{u} = [u_{i_0},u_{i_1},u_{i_2},u_{i_3},u_{i_4}], \\boldsymbol{v} = [v_{i_0},v_{i_1},v_{i_2},v_{i_3},v_{i_4}]， 则曲面S(u,v)的方程为： S(u,v) = \\sum_{i=0}^nP_iN[u_{i_0},u_{i_1},u_{i_2},u_{i_3},u_{i_4}](u)N[v_{i_0},v_{i_1},v_{i_2},v_{i_3},v_{i_4}](v) 为了表示T样条，需要表示T样条的T网格，关键是表示每个T节点和T节点之间的连接关系，为此，本软件使用Node和Mesh两个数据结构，能够很方便的表示T样条。 Node template class Node{ friend class Mesh; public: Node(int num=0):order(num),data(),s(),t(),adj(),valid(true){} ~Node(); public: int order; // the order of node: 1,2,3,... T data; // point coordinate Array s; // knot vector of s-direction Array t; // knot vector of s-direction Array*,4> adj; // pointer of lower, right,upper,left node bool valid; }; Node类用于表示T节点，包含了每个节点的标号、控制点坐标、s,t方向的节点向量和相邻的下、右、上、左方向的节点。 Mesh class Mesh{ private: Mesh& operator=(const Mesh&){} public: Mesh():width(1.0),height(1.0),id(-1){} Mesh(const Mesh& other);// deep copy ~Mesh(); public: // organizing node in a good data structure map*> > s_map; // s_map[s][t] map*> > t_map; // t_map[t][s] vector*> nodes; int id; private: // 边界参数值 double width; double height; // 离散得到的三角网格 Eigen::MatrixXd mesh_V; Eigen::MatrixXi mesh_F; Viewer* viewer; vector> s_cache; // 缓存每个节点计算过的s方向基函数值 vector> t_cache; // 缓存每个节点计算过的t方向基函数值 }; Mesh通过vector*> nodes顺序存储了所有的T节点， 又通过s_map,t_map的特殊结构组织了T样条的所有节点，能够很方便由s,t参数值获得相应的节点。 Tspline文件格式 以下几个函数用于读取和保存Tspline，以及将T样条曲面离散保存为三角网格、四边网格。 // load int loadMesh(string); // save int saveMesh(string); // 按resolution间隔划分参数域，将曲面离散为三角网格并保存为OBJ格式 void saveAsObj(string, double resolution=0.01); // 按resolution间隔划分参数域，将曲面离散为四边网格并保存为OBJ格式 void saveAsQuadObj(string, double resolution = 0.01); T样条详细的文件格式见loadMesh,saveMesh的具体实现，具体例子见out/tspline目录下的文件。 T样条显示 显示相关函数如下： void drawTmesh(); void drawControlpolygon(); void drawSurface(double resolution = 0.01); void draw(bool tmesh, bool polygon, bool surface,double resolution = 0.01); 调用draw函数可以通过tmesh,polygon,surface3个布尔变量控制显示T-preimage,T样条控制网格，T样条曲面。在本软件中，这些切换可以通过键盘操作，详情见下一节。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 11:44:29 "},"chapter3/MeshRender.html":{"url":"chapter3/MeshRender.html","title":"MeshRender窗口显示Tspline","keywords":"","body":"MeshRender窗口显示Tspline 相关文件： MeshRender.h MeshRender.cpp 为了方便显示T样条，而且轻松切换T样条的不同显示模式，本软件添加了MeshRender模块，可以通过键盘切换不同显示模式并且易于使用。 MeshRender设计 #ifndef MESHRENDER_H #define MESHRENDER_H #include \"Window.h\" #include \"utility.h\" class MeshRender : public Window { public: MeshRender(t_mesh::Mesh3d* _mesh, bool _showmesh = false, bool _showpolygon = true, bool _showsurface = true, double _resolution = 0.01) :mesh(_mesh), showmesh(_showmesh), showpolygon(_showpolygon), showsurface(_showsurface), resolution(_resolution) { mesh->setViewer(&viewer); } protected: // 重写draw函数用于T样条的显示及键盘控制 void draw() override; private: // 需要显示的T样条 t_mesh::Mesh3d* mesh; // 布尔变量用于控制T样条显示模式 bool showmesh; bool showpolygon; bool showsurface; double resolution; }; #endif // !MESHRENDER_H 由于显示T样条是基于Window模块的，因此MeshRender继承了Window并重写了draw函数，在其中加入了T样条的显示及键盘控制，draw函数的代码如下： void MeshRender::draw() { mesh->draw(showmesh, showpolygon, showsurface, resolution); viewer.callback_key_down = [&](igl::opengl::glfw::Viewer& viewer, unsigned char key, int modifier) ->bool { if (key == 32) { /*viewer.data().clear(); insert_loop(viewer);*/ } else if (key == 'M') { viewer.data().clear(); showmesh = !showmesh; mesh->draw(showmesh, showpolygon, showsurface); } else if (key == 'P') { viewer.data().clear(); showpolygon = !showpolygon; mesh->draw(showmesh, showpolygon, showsurface); } else if (key == 'S') { viewer.data().clear(); showsurface = !showsurface; mesh->draw(showmesh, showpolygon, showsurface); } return false; }; } 如代码所示，通过M,P,S三个按键，可以很方便的切换T样条的显示模式。 使用方法 有了MeshRender模块，代码可非常简洁明了。 以Test.cpp中的显示T样条曲面为例，代码如下： void Test::test_Mesh() { Mesh3d mesh; mesh.loadMesh(\"../out/tspline/bonnet.cfg\"); // 通过MeshRender模块显示T样条曲面 // 初始时显示模式为仅显示控制网格及曲面 MeshRender render(&mesh, false, true, true); render.launch(); } Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 15:51:31 "},"chapter4/":{"url":"chapter4/","title":"Volume(样条体)","keywords":"","body":"Volume(样条体) 相关文件： Volume.h Volume.cpp 常用的样条体有B样条体和T样条体，为了复用代码，本软件定义了一个抽象基类Volume Volume类 #ifndef VOLUME_H #define VOLUME_H #include \"utility.h\" using namespace std; using namespace igl::opengl::glfw; using namespace t_mesh; class Volume { public: Volume():id(-1), reverse(false){} void setViewer(Viewer* viewer) { this->viewer = viewer; // 在头文件中内联，若在cpp中用inline，会导致其他文件找不到定义 } void draw(bool tmesh, bool polygon, bool surface, double resolution = 0.01); // calculate the coordinate at paramter (u,v,w) virtual Point3d eval(double u, double v, double w) = 0; // read volume from file virtual int readVolume(string) = 0; // save volume to file virtual int saveVolume(string) = 0; // 通过将参数域按resolution分割，将体离散为六面体网格 int saveAsHex(string, double resolution = 0.01); void setReverse(bool _reverse) { reverse = _reverse; } protected: virtual void drawTmesh() = 0; virtual void drawControlpolygon() = 0; // 在体的边界面画出参数线 virtual void drawParamCurve() = 0; // 画出体的六个边界面 virtual void drawVolume(double resolution = 0.01); protected: Viewer* viewer; int id; bool reverse; // u,v,w是否满足右手法则，不满足则需要设置为true }; #endif // !VOLUME_H Volume类是一个抽象基类，BsplineVolume,TsplineVolume会继承Volume类并给出相应虚函数的各自实现。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 15:50:59 "},"chapter4/BsplineVolume.html":{"url":"chapter4/BsplineVolume.html","title":"BsplineVolume","keywords":"","body":"BsplineVolume 相关文件： BsplineVolume.h BsplineVolume.cpp 一个B样条体的方程可表示如下： H(u,v,w) = \\sum_{i=0}^m\\sum_{j=0}^n\\sum_{l=0}^pP_{ijl}N_{i,k_u}(u)N_{j,k_v}(v)N_{l,k_w}(w) BSplineVolume类 #pragma once #ifndef BSPLINEVOLUME_H #define BSPLINEVOLUME_H #include \"Volume.h\" #include \"FitPoint.hpp\" const double PI = 3.141592653; class BsplineVolume :public Volume{ public: vector>> control_grid; // 控制网格 vector knot_vector; // u,v,w方向的节点向量 // 用于体拟合迭代时缓存相应基函数的值 vector>>> matri; vector Bi_start_indexs; vector Bj_start_indexs; vector Bk_start_indexs; }; #endif // !BSPLINEVOLUME_H 其中control_grid, knot_vector是B样条体的控制网格和u,v,w方向的节点向量。 API 以下是BsplineVolume主要的函数，其他函数及具体实现见代码。 #pragma once #ifndef BSPLINEVOLUME_H #define BSPLINEVOLUME_H #include \"Volume.h\" #include \"FitPoint.hpp\" const double PI = 3.141592653; class BsplineVolume :public Volume{ public: // 获取参数值(u,v,w)对应的点的坐标 Point3d eval(double u, double v, double w) override; // read volume from file int readVolume(string) override; // save volume to file int saveVolume(string) override; // 获取参数值为t的等参面，dir为'u'或'v'或'w' void get_isoparam_surface(NURBSSurface& surface, double t, char dir); // 使用优化方法，生成一个拟合指定点，且雅克比值很好的B样条体 void fitBsplineSolid(vector& fit_points, int x_points, int y_points, int z_points, double alpha, double delta); //体拟合迭代的误差 double GetSoildFiterror(vector& fit_points, int x_points, int y_points, int z_points, double alpha, double delta); // lspia 拟合给定的数据点 void lspia(vector& fit_points, int x_points, int y_points, int z_points, int max_iter_num = 100, double eps = 1e-5); }; #endif // !BSPLINEVOLUME_H Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 16:26:10 "},"chapter4/TsplineVolume.html":{"url":"chapter4/TsplineVolume.html","title":"TsplineVolume","keywords":"","body":"TsplineVolume 相关文件： TsplineVolume.h TsplineVolume.cpp 本软件中的T样条体实际上是一个半结构的B样条体，即在w方向上有着统一的节点向量。 TsplineVolume类 #ifndef TSPLINEVOLUME_H #define TSPLINEVOLUME_H #include \"Volume.h\" class TsplineVolume : public Volume{ private: TsplineVolume& operator=(const TsplineVolume&){} public: TsplineVolume(){} TsplineVolume(const TsplineVolume& other); ~TsplineVolume(); public: map w_map; // T样条体由多层T网格组成，每层T网格对应一个w方向节点值 Eigen::VectorXd w_knots; // w向节点向量 }; #endif // !TSPLINEVOLUME_H API 以下是TsplineVolume主要的函数，其他函数及具体实现见代码。 #ifndef TSPLINEVOLUME_H #define TSPLINEVOLUME_H #include \"Volume.h\" class TsplineVolume : public Volume{ private: TsplineVolume& operator=(const TsplineVolume&){} public: TsplineVolume(){} TsplineVolume(const TsplineVolume& other); ~TsplineVolume(); // 获取参数值为(u,v,w)的点的坐标 Point3d eval(double u, double v, double w) override; // read volume from file int readVolume(string) override; // save volume to file int saveVolume(string) override; // insert a layer to the T-mesh of this volume void insert(double w, Mesh3d* mesh); // get the number of nodes int get_num()const; }; #endif // !TSPLINEVOLUME_H Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 16:19:54 "},"chapter4/VolumeRender.html":{"url":"chapter4/VolumeRender.html","title":"VolumeRender窗口显示样条体","keywords":"","body":"VolumeRender窗口显示样条体 相关文件： VolumeRender.h VolumeRender.cpp 与MeshRender类似， 为了方便显示T样条体，而且轻松切换T样条体的不同显示模式，本软件添加了VolumeRender模块，可以通过键盘切换不同显示模式并且易于使用。 VolumeRender设计 #ifndef VOLUMERENDER_H #define VOLUMERENDER_H #include \"Window.h\" #include \"Volume.h\" class VolumeRender : public Window { public: VolumeRender(Volume* _volume, bool _showmesh = false, bool _showpolygon = true, bool _showvolume = true, double _resolution = 0.1) :volume(_volume), showmesh(_showmesh), showpolygon(_showpolygon), showvolume(_showvolume), resolution(_resolution) { volume->setViewer(&viewer); } protected: void draw() override; private: Volume* volume; bool showmesh; bool showpolygon; bool showvolume; double resolution; }; #endif // !VOLUMERENDER_H 由于显示T样条体是基于Window模块的，因此VolumeRender继承了Window并重写了draw函数，在其中加入了T样条体的显示及键盘控制，draw函数的代码如下： #include \"VolumeRender.h\" void VolumeRender::draw() { volume->draw(showmesh, showpolygon, showvolume, resolution); viewer.callback_key_down = [&](igl::opengl::glfw::Viewer& viewer, unsigned char key, int modifier) ->bool { if (key == 32) { } else if (key == 'M') { viewer.data().clear(); showmesh = !showmesh; volume->draw(showmesh, showpolygon, showvolume, resolution); } else if (key == 'P') { viewer.data().clear(); showpolygon = !showpolygon; volume->draw(showmesh, showpolygon, showvolume, resolution); } else if (key == 'S') { viewer.data().clear(); showvolume = !showvolume; volume->draw(showmesh, showpolygon, showvolume, resolution); } return false; }; } 如代码所示，通过M,P,S三个按键，可以很方便的切换样条体的显示模式。 使用方法 有了VolumeRender模块，代码可非常简洁明了。 以Test.cpp中的显示B样条体为例，代码如下： void Test::test_BsplineVolume(string modelname, double ratio, bool reverse) { BsplineVolume volume; volume.readVolume(\"../out/volume/\" + modelname + \"_bspline.txt\"); volume.setReverse(reverse); // 使用VolumeRender模块显示B样条体 VolumeRender render(&volume, false, false, true, ratio); render.launch(); } Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 16:29:40 "},"chapter5/":{"url":"chapter5/","title":"T样条曲面蒙皮","keywords":"","body":"T样条曲面蒙皮 相关文件： skinning.h skinning.cpp NasriMethod.h NasriMethod.cpp MinJaeMethod.h MinJaeMethod.cpp PiaMethod.h PiaMethod.cpp PiaNasriMethod.h PiaNasriMethod.cpp PiaMinJaeMethod.h PiaMinJaeMethod.cpp 其中Skinning类是对各种T样条蒙皮方法步骤进行抽象得到的一个抽象基类； NasriMethod, MinJaeMethod分别是对Nasri 2012, MinJae 2018这两篇论文中T样条曲面蒙皮方法的具体实现； PiaMethod是对本文提出的基于引导线和LSPIA的T样条蒙皮方法步骤进行抽象得到的一个抽象基类； PiaNasriMethod, PiaMinJaeMethod分别是本文方法在插入一条中间线和两条中间线时的具体实现。 T样条蒙皮方法的理论知识见Nasri 2012, MinJae 2018，及本软件对应毕业论文 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 16:47:28 "},"chapter5/Skinning.html":{"url":"chapter5/Skinning.html","title":"Skinning抽象基类","keywords":"","body":"Skinning抽象基类 相关文件： skinning.h skinning.cpp T样条曲面蒙皮方法主要有以下几个步骤： 对给定的曲线进行参数化，为每一条曲线赋予一个参数值 根据给定的NURBS曲线，初始化T-preimage，即将NURBS曲线的节点组成T-preimage 插入中间线，如Nasri方法中插入一列中间线，MinJae方法中插入两列中间线 根据插入的中间线的点的坐标，通过Nasri论文中的公式更新T样条曲面控制顶点的坐标，从而满足插值性 Skinning类 为此，本软件使用了面向对象中的多态设计思想，设计了一个Skinning抽象基类，用于抽象上述的计算步骤，具体代码如下： #ifndef SKINNING_H #define SKINNING_H #include \"utility.h\" #include \"NURBSCurve.h\" using namespace std; using namespace t_mesh; class Skinning { public: Skinning(const vector& _curves) :curves(_curves) { curves_num = curves.size(); } virtual void parameterize(); // 曲线参数化得到u方向参数 u_knots virtual void init() = 0; // 根据NUUBSCurve初始化T-preimage virtual void insert() = 0; // 在T-preimage中插入中间节点 virtual void calculate(); // 计算流程 // update的辅助函数，用于计算基函数的线性组合系数 void basis_split(const map*>& fewer_map, const map*>& more_map, map& coeff); // update coordinates of control points by the formula from (nasri 2012) // aX' + bW + cY' = V void update(); // 用于skinning过程中显示中间结果 void setViewer(Viewer* _viewer) { viewer = _viewer; } public: Mesh3d tspline; protected: int curves_num; VectorXd s_knots; vector curves; Viewer* viewer; }; #endif // !SKINNING_H 在Skinning中calculate函数是计算的入口，用于执行各个步骤，默认的计算步骤如下： void Skinning::calculate() { // 1. compute s-knot for curves parameterize(); // 2. construct basis T-mesh init(); // 3. insert intermediate vertices // the coordinate of vertices is the midpoint of the corresponding points in C_r and C_(r+1) insert(); // 4. update coordinates of control points by the formula from (nasri 2012) // aX' + bW + cY' = V update(); } 其他所有的T样条蒙皮方法的具体实现类均继承自Skinning类。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 16:59:19 "},"chapter5/Nasri_MinJae.html":{"url":"chapter5/Nasri_MinJae.html","title":"NasriMethod&MinJaeMethod","keywords":"","body":"NasriMethod&MinJaeMethod 相关文件： NasriMethod.h NasriMethod.cpp MinJaeMethod.h MinJaeMethod.cpp NasriMethod NasriMethod实现了Nasri 2012论文中的方法。 具体实现中是通过重写insert方法，按论文中的方式插入一列中间线。 #ifndef NASRIMETHOD_H #define NASRIMETHOD_H #include \"Skinning.h\" class NasriMethod : public Skinning { public: NasriMethod(const vector& _curves) :Skinning(_curves) { } void init() override; // 插入一列中间线 void insert() override; }; #endif // !NASRIMETHOD_H MinJaeMethod MinJaeMethod实现了MinJae 2018论文中的方法。 具体实现中是通过重写insert方法，按论文中的方式插入两列中间线，并按照论文中的方法迭代更新插入的中间线控制点坐标，从而得到更好的形状。 #ifndef MINJAEMETHOD_H #define MINJAEMETHOD_H #include \"Skinning.h\" class MinJaeMethod : public Skinning { public: MinJaeMethod( const vector& _curves, int _sampleNum = 10, int _maxIterNum = 20, double _eps = 1e-5) :Skinning(_curves),sampleNum(_sampleNum), maxIterNum(_maxIterNum),eps(_eps) { } void init() override; // 根据NUUBSCurve初始化T-preimage void insert() override; // 在T-preimage中插入中间节点 void calculate() override; // 计算流程 private: void inter_init(); // 初始化中间点的坐标 double inter_update(); // 更新中间点的坐标 private: const int sampleNum; const int maxIterNum; const double eps; map> initial_cpts; }; #endif // !MINJAEMETHOD_H 其中calculate计算流程重写为： void MinJaeMethod::calculate() { // 1. compute s-knot for curves parameterize(); // 2. construct basis T-mesh init(); // 3. insert intermediate vertices // the coordinate of vertices is the midpoint of the corresponding points in C_r and C_(r+1) insert(); // 4. 初始化中间点坐标 inter_init(); update(); // 5. 迭代更新中间点坐标 double error = 1.0; for (int i = 0; i 其中每个步骤的具体实现见代码。 使用方法 main.cpp中包含了一些T样条曲面蒙皮方法的测试用例，可参照使用。 // main.cpp Test::test_circle_skinning(); Test::test_venus_skinning(); Test::test_venus_skinning_helper_points(); Test::test_Bsurface_skinning(); Test::test_chess_skinning(); Test::test_ring_skinning(); Test::test_helicoidal_skinning(); Test::test_bonnet_skinning(); Test::test_door_skinning(); Test::test_face_skinning(); Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 17:22:48 "},"chapter5/PiaMethod.html":{"url":"chapter5/PiaMethod.html","title":"PiaNasriMethod&PiaMinJaeMethod","keywords":"","body":"PiaNasriMethod&PiaMinJaeMethod 相关文件： PiaMethod.h PiaMethod.cpp PiaNasriMethod.h PiaNasriMethod.cpp PiaMinJaeMethod.h PiaMinJaeMethod.cpp 本文提出的基于引导线和LSPIA的T样条曲面蒙皮方法的主要步骤如下图所示： 对上述步骤进行抽象得到了PiaMethod基类，该基类由于一开始的设计问题，实现的是通过局部加细拟合给定的曲线，与T样条曲面蒙皮无关，但是继承PiaMethod的两个类PiaNasriMethod, PiaMinJaeMethod是基于引导线的T样条曲面蒙皮方法的具体实现。 PiaNasriMethod 具体代码如下： #ifndef PIANASRIMETHOD_H #define PIANASRIMETHOD_H #include \"PiaMethod.h\" #include \"NURBSSurface.h\" #include class PiaNasriMethod :public PiaMethod { public: PiaNasriMethod(const vector& _curves, int _maxIterNum = 100, double _eps = 1e-5) :PiaMethod(_curves, _maxIterNum, _eps) { } // 设置辅助点 void set_helper_points(const MatrixXd& points) { helper_points.resize(points.rows()); for (int i = 0; i param_helper_points(); void init() override; // 根据NUUBSCurve初始化T-preimage void insert() override; // 按一定规则在误差大的地方插入节点，局部加细 void calculate() override; // 计算流程 public: void sample_fitPoints_1(); void sample_fitPoints_2(); // 生成引导线，并采样得到数据点 void sample_fitPoints() override; void pia() override; private: vector curve_points; vector inter_points; vector helper_points; }; #endif // !PIANASRIMETHOD_H calculate中的计算流程如下： void PiaNasriMethod::calculate() { parameterize(); init(); insert(); sample_fitPoints_2(); // 生成引导线，并采样得到数据点 fitPoints = curve_points; fitPoints.insert(fitPoints.end(), inter_points.begin(), inter_points.end()); update(); fit(); cout 各个步骤的具体实现见代码，PiaMinJaeMethod与PiaNasriMethod类似。 使用方法 main.cpp中包含了一些基于引导线的T样条曲面蒙皮方法的测试用例，可参照使用。 // main.cpp Test::test_circle_skinning(); Test::test_venus_skinning(); Test::test_venus_skinning_helper_points(); Test::test_Bsurface_skinning(); Test::test_chess_skinning(); Test::test_ring_skinning(); Test::test_helicoidal_skinning(); Test::test_bonnet_skinning(); Test::test_door_skinning(); Test::test_face_skinning(); Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 17:40:50 "},"chapter6/":{"url":"chapter6/","title":"T样条体蒙皮","keywords":"","body":"T样条体蒙皮 相关文件： VolumeSkinning.h VolumeSkinning.cpp VolumePiaMethod.h VolumePiaMethod.cpp T样条体蒙皮是从T样条曲面蒙皮延伸的概念，用于从一组给定的T样条曲面生成一个插值这组曲面的T样条体。 VolumeSkinning中采用了插入两排中间面的方式，并通过与MinJae 2018 类似的插值公式使得满足插值性。 VolumePiaMethod是基于引导线、LSPIA、优化的T样条体蒙皮方法，用于生成一个既满足插值性，且雅克比值全为正的适用于等几何分析的T样条体。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 17:49:46 "},"chapter6/VolumeSkinning.html":{"url":"chapter6/VolumeSkinning.html","title":"VolumeSkinning","keywords":"","body":"VolumeSkinning 相关文件： VolumeSkinning.h VolumeSkinning.cpp VolumeSkinning中采用了插入两排中间面的方式，并通过与MinJae 2018 类似的插值公式使得满足插值性。 且VolumeSkinning中也抽象了体蒙皮的基本步骤。 VolumeSkinning类 #ifndef VOLUMESKINNING_H #define VOLUMESKINNING_H #include \"TsplineVolume.h\" #include \"NURBSCurve.h\" class VolumeSkinning { public: VolumeSkinning(const vector& _surfaces) :surfaces(_surfaces) { surfaces_num = surfaces.size(); } virtual void parameterize(); // 曲线参数化得到w方向参数 w_params virtual void init(); // 根据T样条曲面初始化体网格 virtual void insert(); // 在体网格中插入中间面 virtual void calculate(); // 计算流程 // update coordinates of control points by the formula from (nasri 2012) // aX + bW + cY = V void update(); // 用于skinning过程中显示中间结果 void setViewer(Viewer* _viewer) { viewer = _viewer; } private: Point3d centerOfmesh(const Mesh3d& mesh); public: TsplineVolume volume; protected: vector surfaces; int surfaces_num; Eigen::VectorXd w_params; Viewer* viewer; }; #endif // !VOLUMESKINNING_H calculate中包含了具体的计算步骤： void VolumeSkinning::calculate() { // 1. compute w_params for surfaces parameterize(); // 2. construct basis 3-dimension T-mesh init(); // 3. insert intermediate surfaces // the coordinate of vertices is the midpoint of the corresponding points in C_r and C_(r+1) insert(); // 4. update coordinates of control points by the formula from (nasri 2012) // aX' + bW + cY' = V update(); } 各个步骤具体的实现见代码。 Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 17:54:31 "},"chapter6/VolumePiaMethod.html":{"url":"chapter6/VolumePiaMethod.html","title":"VolumePiaMethod","keywords":"","body":"VolumePiaMethod 相关文件： VolumePiaMethod.h VolumePiaMethod.cpp VolumePiaMethod是基于引导线、LSPIA、优化的T样条体蒙皮方法，用于生成一个既满足插值性，且雅克比值全为正的适用于等几何分析的T样条体。 该方法的具体算法步骤如下： 由于该步骤与VolumeSkinning有重合部分，因此设计时VolumePiaMethod类继承自VolumeSkinning类。 VolumePiaMethod类 #ifndef VOLUMEPIAMETHOD_H #define VOLUMEPIAMETHOD_H #include \"VolumeSkinning.h\" #include \"FitPoint.hpp\" #include \"BsplineVolume.h\" class VolumePiaMethod :public VolumeSkinning { public: VolumePiaMethod(const vector& _surfaces,int _maxIterNum=100,double _eps = 1e-5) :VolumeSkinning(_surfaces),maxIterNum(_maxIterNum),eps(_eps) { } void calculate() override; // 计算流程 public: // 设置辅助点 void set_helper_points(const MatrixXd& points) { helper_points.resize(points.rows()); for (int i = 0; i fitPoints; vector surface_points; vector inter_points; vector helper_points; vector> basis_cache; // (B_i(t_j) vector basis_cache_sum; // sum_j (B_i(t_j) }; #endif // !VOLUMEPIAMETHOD_H calculate中定义了具体的处理流程： void VolumePiaMethod::calculate() { parameterize(); init(); insert(); // 生成形状引导线，分段优化生成Jacobian值全为正的B样条体，采样用于拟合的点 sample_fitPoints_multiVolume(); fitPoints = surface_points; fitPoints.insert(fitPoints.end(), inter_points.begin(), inter_points.end()); cal_basis_cache(); // 计算基函数在fitPoints参数位置的值， 这样在fit()和pia()时不需要再重新计算 cout 各个步骤具体实现见代码。 使用方法 main.cpp中包含了一些T样条体蒙皮的测试用例，可参照使用。 Test::test_VolumeSkinning(\"tooth\", 3); Test::test_VolumeSkinning(\"venus\", 3e-3); Test::test_VolumeSkinning(\"isis\", 5e-3); Test::test_VolumeSkinning(\"isis\", 1e-2); Test::test_VolumeSkinning(\"moai\", 0.04); Test::test_VolumeSkinning(\"moai_new\", 0.03); Test::test_VolumeSkinning(\"moai_fitbspline\", 0.04); Test::test_VolumeSkinning(\"Ssolid\", 0.05); Test::test_VolumeSkinning(\"head\", 0.01); Test::test_VolumeSkinning(\"duck\", 2); Test::test_VolumeSkinning(\"duck_new\", 2); Copyright © Jiaming Ai 2019 all right reserved，powered by Gitbook本指南发布时间： 2020-03-08 18:04:54 "}}